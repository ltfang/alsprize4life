################################################################################

Slopes <- function(dataset,start,end,period) {
# Given an ALSFRS dataset, computes the ALSFRS slope between start and end,
# as defined by timing flag 
#
# Args:
#	dataset generated by GetAlsfrsData
#	start - the start time in months
#	end - the end time in months 
#	period - when p, calculates past slopes: ie, slope based on first 
#			visit >= specified start month and last visit <=
#			specified end month, using alsfrs.delta as time measure 
#			- when f, calculates future slopes: ie, slope based on first 
#			visit > specified start and end months, using delta.ref as time
#			measure
#		   
# Returns:
#	a dataframe with columns for subject.id and the corresponding slope
#
# Example usage:
#	for future slopes: future.slopes<-Slopes(alsfrs.data,3,12,"f")
#	for past slopes: past.slopes<-Slopes(alsfrs.data,0,3,"p")

	
	# Get slope components
	slope.data<-SlopeComponents(dataset,start,end,period) 
	
	# Calculate slopes
	slopes<-(slope.data$last.score-slope.data$first.score)/
		(slope.data$last.date-slope.data$first.date)
	
	return(slopes)
}
SlopeComponents <- function(dataset,start,end,period) {
	# Given an ALSFRS dataset, computes the slope components, ie the first and last 
	# scores and dates given the time period desired 
	#
	# Args:
	#	dataset generated by GetAlsfrsData
	#	start - the start time in months
	#	end - the end time in months 
	#	period - when p, calculates past slopes: ie, slope based on first 
	#			visit >= specified start month and last visit <=
	#			specified end month, using alsfrs.delta as time measure 
	#			- when f, calculates future slopes: ie, slope based on first 
	#			visit > specified start and end months, using delta.ref as time
	#			measure
	#		   
	# Returns:
	#	a dataframe with columns for subject.id, first.score, first.date, last.score,
	# 	and last.date
	#
	# Example usage:
	#	for future slopes: future.slopes<-SlopeComponents(alsfrs.data,3,12,"f")
	#	for past slopes: past.slopes<-SlopeComponents(alsfrs.data,0,3,"p")

	# Get vector of all unique subject.ids
	subjects<-unique(dataset$subject.id)
	# run CleanDelta to get rid of rows where ten questions have not been 
	# answered, deltas equal to NA, and convert deltas to months
	dataset<-CleanDelta(dataset)
	# Get indices for first and last visits if calculating past slopes
	if (period == "p") {
		ind.all<-PastIndex(dataset,start,end)
		# Merge with vector of all subject ids to make sure each subject id
		# has a corresponding slope, even if it is NA
		ind.all<-merge(subjects,ind.all,by.x=1,by.y="subject.id",all=TRUE)
		first.ind<-ind.all$ind.start 
		last.ind<-ind.all$ind.end
	}
	# Get indices for first and last visits if calculating future slopes
	else if (period == "f") {
		# Run DeltaRef if it has not already been run on the dataset
		if (!any(colnames(dataset)=="delta.ref")) {
			dataset<-DeltaRef(dataset) 
		}	
		ind.start<-FutureIndex(dataset,start) 
		ind.end<-FutureIndex(dataset,end)
		ind.all<-merge(ind.start,ind.end,by="subject.id")
		colnames(ind.all)<-c("subject.id","ind.start","ind.end")
		# Merge with vector of all subject ids to make sure each subject id
		# has a corresponding slope, even if it is NA
		ind.all<-merge(subjects,ind.all,by.x=1,by.y="subject.id",all=TRUE)
		first.ind<-ind.all$ind.start 
		last.ind<-ind.all$ind.end
	}
	else { 
	print("Specify f or p")
	}
	#Get the ALSFRS scores
	dataset<-AlsfrsScore(dataset)
	#Get first and last scores and dates for slope calculation
	first.score<-dataset$alsfrs.score[first.ind]
	first.date<-dataset$months[first.ind]
	last.score<-dataset$alsfrs.score[last.ind]
	last.date<-dataset$months[last.ind]
	slope.data<-data.frame(subject.id=subjects,first.score,first.date,last.score,
		last.date)
	return(slope.data)
}

CleanDelta<-function(dataset) {
	# Given an ALSFRS dataset, drops rows where not all ten questions have
	# been answered, drops all rows where alsfrs.delta = NA, and converts
	# alsfrs.delta to months.
	#
	# Args:
	#	dataset generated by GenAlsfrsData 
	#
	# Returns:
	#	the original dataset cleaned of ten questions and NAs, with an 
	# 	additional column months, which is alsfrs.delta in months.
	
	alsfrs.questions<-GetAlsfrsQuestions()
	# mark all rows with ten questions scored
	ten.questions<-rowSums(!is.na(dataset[,which(colnames(dataset) 
		%in% alsfrs.questions)]))>=10 
	# drop all records without ten questions scored
	dataset<-dataset[ten.questions,]
	# drop all rows where alsfrs.delta = NA
	dataset<-dataset[!is.na(dataset$alsfrs.delta),]
	# convert delta to months
	months<-DaysToMonths(dataset$alsfrs.delta)
	dataset<-cbind(dataset,months)
	return(dataset)
}

DeltaRef <- function(dataset) {
	# Given an ALSFRS dataset on which CleanDelta has been run, 
	# identifies the reference visit, that is, the row that corresponds 
	# to the first time all ten questions are answered, and then calculates
	# the difference between each visit and the reference visit  in months.
	#
	# Args:
	#	dataset generated by GenAlsfrsData on which CleanDelta has been run
	#
	# Returns:
	#	the original dataset with an additional column "delta.ref" of the 
	#	difference between the time of each visit and the time of the reference 
	# 	visit in months.

	# mark first row of new subject_id 
	unique<-!duplicated(dataset$subject.id)
	# Create a matrix with a column of subject ids and column of corresponding 
	# reference visit time in months
	ref.visit<-cbind(dataset$subject.id[unique],dataset$months[unique])
	colnames(ref.visit)<-c("subject.id","ref.month")
	# Merge ref.visit and dataset so that row operations can be performed 
	dataset<-merge(dataset,ref.visit,by="subject.id")
	cols<-colnames(dataset)
	dataset<-cbind(dataset,(dataset$months-dataset$ref.month))
	colnames(dataset)<-c(cols,"delta.ref")
	# Compute difference in months from reference date and return
	return(dataset)
}


PastIndex<-function(dataset,start,end) {
	# Given an ALSFRS dataset, finds indices corresponding to the desired visits
	# to calculate future slopes
	#
	# Args:
	#	dataset: a dataset generated by GenAlsfrsData on which CleanDelta has
	#	been run
	#	start: time in months for start date
	#	end: time in months for end date
	#	
	# Returns:
	#	a matrix with a column of subject ids, a column of indices corresponding 
	# 	to the starting visit and a column of indices corresponding to the ending
	# 	visit for each subject id.

	# Find all indices that correspond to visit that occurs after specified 
	# start month 
	ind<-which(dataset$alsfrs.delta>=start)
	unique<-!duplicated(dataset$subject.id[ind])
	ind.start<-ind[unique]
	ind.start<-cbind(dataset$subject.id[ind.start],ind.start)
	colnames(ind.start)<-c("subject.id","ind.start")

	# Find all indices that correspond to visits that occur before specified 
	# end month
	ind<-which(dataset$months<=end)
	# Mark changes in subject id in vector created from indices
	unique<-!duplicated(dataset$subject.id[ind])
	unique<-which(unique==TRUE)
	ind.end<-c(ind[unique-1],ind[length(ind)])
	ind.end<-cbind(dataset$subject.id[ind.end],ind.end)
	colnames(ind.end)<-c("subject.id","ind.end")
	
	# Merge start and end indices with subject ids
	ind.all<-merge(ind.start,ind.end,by="subject.id",all=TRUE)
	colnames(ind.all)<-c("subject.id","ind.start","ind.end")
	return(ind.all)
}	

FutureIndex<-function(dataset,month) {
	# Given an ALSFRS dataset, finds indices corresponding to the desired visits
	# to calculate future slopes
	#
	# Args:
	#	dataset: a dataset generated by GenAlsfrsData, on which CleanDelta and 
	#	DeltaRef have been run 
	#	month: time in months for start or end measure

	# Returns:
	#	a matrix with a column of subject ids and a column of indices corresponding 
	# 	to the desired visit 

	# Find last visit for each subject id
	# Create a vector of row indices corresponding to final visit of each 
	# subject.id
	ind<-c(1:length(dataset$delta.ref))
	ind.final<-c(ind[which(diff(dataset$delta.ref==0)==1)],length(dataset$delta.ref))
	# Combine with subject id vector to create matrix with both
	ind.final<-cbind(dataset$subject.id[ind.final],ind.final)
	colnames(ind.final)<-c("subject.id","ind.final")
			
	# Find first visit after 'month' months
	# Find indices corresponding to first row of new subject and all visits > 'month'
	# months after the reference visit
	ind<-which(dataset$delta.ref>month)
	unique<-!duplicated(dataset$subject.id[ind])
	ind.month<-ind[unique]
	ind.month<-cbind(dataset$subject.id[ind.month],ind.month)
	colnames(ind.month)<-c("subject.id","ind.month")
	
	# Combine last visit and 'month' visit to get visit indices
	ind.visit<-merge(ind.final,ind.month,all=TRUE,by="subject.id")
	# Replace 'month' visit with last visit when value is NA
	ind.NA<-which(is.na(ind.visit$ind.month))
	ind.visit$ind.month[ind.NA]<-ind.visit$ind.final[ind.NA]
	return(ind.visit[,colnames(ind.visit)!="ind.final"])
}

